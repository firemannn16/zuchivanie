<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Тренажёр арабских слов — Заучивание + Практика</title>
<style>
  :root{--bg:#ffffff;--muted:#666;--accent:#0a6;--danger:#c33}
  body{font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:#111;margin:18px;max-width:980px}
  #wrap{margin:0 auto}
  h1{margin:6px 0 12px}
  .dua{background:#fff;padding:14px;border-radius:10px;border:1px solid #eee;margin-bottom:12px}
  .dua .arab{direction:rtl;font-size:2.2rem;font-weight:700;margin:8px 0;text-align:center}
  .card{background:#fff;padding:18px;border-radius:10px;border:1px solid #eee;margin-bottom:12px}
  #arabic{direction:rtl;font-size:2.8rem;text-align:center;min-height:3.6em;display:flex;align-items:center;justify-content:center}
  .controls{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:12px}
  button{padding:10px 14px;border-radius:8px;border:1px solid #ccc;background:#f6f6f6;cursor:pointer;font-size:1rem}
  .btn-primary{background:#e6fff0;border-color:#b6f0c7}
  .btn-danger{background:#fff0f0;border-color:#f0b6b6}
  .small{font-size:0.95rem;color:var(--muted);margin-top:8px;text-align:center}
  .stats{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin-bottom:10px}
  .stat{background:#fafafa;padding:8px 12px;border-radius:8px;border:1px solid #f0f0f0}
  .hidden{display:none}
  input[type="text"]{width:100%;padding:10px;font-size:1rem;border-radius:8px;border:1px solid #ddd;box-sizing:border-box}
  .center{display:flex;justify-content:center;align-items:center;gap:8px}
  /* modal */
  .overlay{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:9999}
  .modal{background:#fff;padding:18px;border-radius:10px;max-width:720px;width:92%;box-shadow:0 10px 30px rgba(0,0,0,0.2)}
  .modal .arab{direction:rtl;font-size:1.8rem;font-weight:700;text-align:right}
  .modal .rus{margin-top:10px;font-size:1.1rem}
  .right{float:right}
  @media(max-width:640px){
    #arabic{font-size:2.2rem;padding:8px}
    .modal{padding:12px}
  }
</style>
</head>
<body>
  <div id="wrap">
    <h1>Тренажёр арабских слов</h1>

    <!-- Дуа экран (показывается при каждом заходе) -->
    <div id="screen-dua" class="dua">
      <div><strong>Перед началом тренировок</strong></div>
      <div class="arab">رَّبِّ زِدْنِى عِلْمًۭا</div>
      <div style="text-align:center;margin-top:6px">Перевод: «Господь мой! Приумножь мои знания»</div>
      <div class="center" style="margin-top:12px">
        <button id="btn-done-dua">Я сделал дуа</button>
      </div>
      <div class="small">Словарь загружается автоматически из <code>words.txt</code>.</div>
    </div>

    <!-- Основной интерфейс -->
    <div id="screen-main" class="hidden">
      <div class="stats">
        <div class="stat">Всего слов: <span id="stat-total">0</span></div>
        <div class="stat">Уже окончательно выучено: <span id="stat-mastered">0</span></div>
        <div class="stat">Осталось в очереди: <span id="stat-remaining">0</span></div>
        <div class="stat">Фаза: <span id="stat-phase">—</span></div>
      </div>

      <div class="card">
        <div id="arabic">…</div>

        <div id="learn-controls" class="controls">
          <button id="btn-know" class="btn-primary">Знаю</button>
          <button id="btn-dont" class="">Не знаю</button>
          <button id="btn-add" class="">Добавить новые слова</button>
          <button id="btn-reset" class="btn-danger">Сбросить прогресс</button>
        </div>

        <div id="practice-area" class="hidden" style="margin-top:12px">
          <div style="margin-bottom:8px"><strong>Практика — введите перевод на русском:</strong></div>
          <input id="practice-input" type="text" autocomplete="off" placeholder="Введите перевод" />
          <div class="center" style="margin-top:8px">
            <button id="practice-submit">Проверить</button>
            <button id="practice-skip">Пропустить (вернуть в повтор)</button>
          </div>
        </div>

        <div id="message" class="small" style="margin-top:12px"></div>
      </div>
    </div>

    <!-- Modal для "Не знаю" -->
    <div id="modal-root"></div>
  </div>

<script>
/* ========== Конфиг ========= */
const BATCH_SIZE = 10;               // сколько слов выучить в каждом раунде перед практикой
const DONT_KNOW_SHOW_MS = 15000;     // 15 секунд
const AUTO_CLOSE_MODAL_MS = DONT_KNOW_SHOW_MS;
const STORAGE_KEY = (() => {
  const path = (location.pathname||'/').replace(/^\/|\/$/g,'').replace(/\//g,'_') || 'root';
  return `arabic_trainer_state_v1_${encodeURIComponent(location.hostname + '_' + path)}`;
})();

/* ========== Состояние ========= */
let allWords = [];           // [{ rawLine, rus: [], arab: "..." }]
let orderQueue = [];         // очередь для заучивания (rawLine strings)
let masteredFinal = [];      // окончательно выученные rawLine's (удаляются навсегда)
let roundMastered = [];      // выученные в текущем раунде (rawLine)
let practiceAccum = [];      // накопленные слова для практики (очередь, grows each round)
let practiceOrder = [];      // текущая очередь практики (rawLines)
let phase = 'learn';         // 'learn' или 'practice'
let currentRaw = null;
let modalTimer = null;

/* ========== DOM ========= */
const screenDua = document.getElementById('screen-dua');
const screenMain = document.getElementById('screen-main');
const btnDoneDua = document.getElementById('btn-done-dua');

const statTotal = document.getElementById('stat-total');
const statMastered = document.getElementById('stat-mastered');
const statRemaining = document.getElementById('stat-remaining');
const statPhase = document.getElementById('stat-phase');

const arabicDiv = document.getElementById('arabic');
const btnKnow = document.getElementById('btn-know');
const btnDont = document.getElementById('btn-dont');
const btnAdd = document.getElementById('btn-add');
const btnReset = document.getElementById('btn-reset');
const messageDiv = document.getElementById('message');

const practiceArea = document.getElementById('practice-area');
const practiceInput = document.getElementById('practice-input');
const practiceSubmit = document.getElementById('practice-submit');
const practiceSkip = document.getElementById('practice-skip');

const modalRoot = document.getElementById('modal-root');

/* ========== Утилиты ========= */
function normalizeLine(l){
  if(!l) return '';
  return l.replace(/^\uFEFF/,'').replace(/[\u2010\u2011\u2012\u2013\u2014\u2015–—−]/g,'-').replace(/\s+/g,' ').trim();
}
function parseLine(raw){
  raw = normalizeLine(raw);
  const parts = raw.split(/[-–—]/);
  const left = (parts[0]||'').trim();
  const right = parts.slice(1).join('-').trim();
  const rus = left ? left.split(',').map(s=>s.trim()).filter(Boolean) : [''];
  return { rawLine: raw, rus, arab: right };
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

/* ========== Сохранение/восстановление ========= */
function saveState(){
  try{
    const st = {
      allRaw: allWords.map(w=>w.rawLine),
      orderQueue: orderQueue.slice(),
      masteredFinal: masteredFinal.slice(),
      roundMastered: roundMastered.slice(),
      practiceAccum: practiceAccum.slice(),
      practiceOrder: practiceOrder.slice(),
      phase,
      currentRaw
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(st));
  }catch(e){ console.warn('saveState error', e); }
}

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    return raw ? JSON.parse(raw) : null;
  }catch(e){ return null; }
}

function clearState(){
  try{ localStorage.removeItem(STORAGE_KEY); }catch(e){}
}

/* ========== Загрузка words.txt (robust) ========= */
async function robustFetchWords(){
  const tries = ['words.txt','./words.txt'];
  try{ tries.push(location.pathname.replace(/\/[^/]*$/,'/') + 'words.txt'); }catch(e){}
  for(const p of tries){
    try{
      const r = await fetch(p);
      if(r.ok) return await r.text();
    }catch(e){}
  }
  // try raw.githubusercontent (assumes repo layout /main/words.txt)
  try{
    const user = location.hostname.split('.')[0] || '';
    const repo = (location.pathname.split('/').filter(Boolean)[0] || '');
    if(user && repo){
      const raw = `https://raw.githubusercontent.com/${user}/${repo}/main/words.txt`;
      const r2 = await fetch(raw);
      if(r2.ok) return await r2.text();
    }
  }catch(e){}
  throw new Error('Не удалось загрузить words.txt');
}

/* ========== Инициализация словаря / восстановление ========= */
async function initDictionary(){
  try{
    const txt = await robustFetchWords();
    const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    // parse to objects
    const parsed = lines.map(parseLine);
    // merge with possibly saved snapshot that contains older lines
    const st = loadState();
    if(st && Array.isArray(st.allRaw) && st.allRaw.length){
      // if state exists, we will try to restore using raw lines approach
      // start with server parsed, then keep state values if raw lines still exist
      allWords = parsed.slice();
      const serverSet = new Set(allWords.map(w=>w.rawLine));
      // restore fields
      orderQueue = (Array.isArray(st.orderQueue) ? st.orderQueue.filter(r=>serverSet.has(r)) : []);
      // append server-new lines which were not in saved snapshot
      const oldSnap = new Set(st.allRaw || []);
      const newOnServer = allWords.map(w=>w.rawLine).filter(r => !oldSnap.has(r));
      for(const r of newOnServer){
        if(!orderQueue.includes(r)) orderQueue.push(r);
      }
      masteredFinal = (Array.isArray(st.masteredFinal) ? st.masteredFinal.filter(r=>serverSet.has(r)) : []);
      roundMastered = (Array.isArray(st.roundMastered) ? st.roundMastered.filter(r=>serverSet.has(r)) : []);
      practiceAccum = (Array.isArray(st.practiceAccum) ? st.practiceAccum.filter(r=>serverSet.has(r)) : []);
      practiceOrder = (Array.isArray(st.practiceOrder) ? st.practiceOrder.filter(r=>serverSet.has(r)) : []);
      phase = st.phase || 'learn';
      currentRaw = (st.currentRaw && serverSet.has(st.currentRaw)) ? st.currentRaw : null;
      // if orderQueue empty, initialize it from allWords excluding masteredFinal
      if(!orderQueue.length){
        orderQueue = allWords.map(w=>w.rawLine).filter(r => !masteredFinal.includes(r));
        shuffle(orderQueue);
      }
    } else {
      allWords = parsed.slice();
      masteredFinal = [];
      roundMastered = [];
      practiceAccum = [];
      practiceOrder = [];
      phase = 'learn';
      currentRaw = null;
      orderQueue = allWords.map(w=>w.rawLine);
      shuffle(orderQueue);
    }
    updateStats();
    saveState();
  }catch(err){
    console.error('initDictionary failed', err);
    alert('Не удалось загрузить words.txt: ' + err.message);
  }
}

/* ========== UI обновления ========= */
function updateStats(){
  statTotal.textContent = allWords.length;
  statMastered.textContent = masteredFinal.length;
  statRemaining.textContent = orderQueue.length;
  statPhase.textContent = phase === 'learn' ? 'Заучивание' : 'Практика';
}

function showMessage(t){
  messageDiv.textContent = t || '';
}

/* ========== Показ текущего слова для заучивания ========= */
function showNextLearn(){
  phase = 'learn';
  updateStats();
  if(orderQueue.length === 0){
    // если очередь пуста — значит либо всё выучено, либо practice осталось
    if(practiceOrder.length === 0 && practiceAccum.length === 0){
      showMessage('Поздравляю — все слова пройдены!');
      arabicDiv.textContent = '🎉 Всё пройдено';
      saveState();
      return;
    } else {
      // если есть что практиковать — перейти в practice
      startPractice();
      return;
    }
  }
  currentRaw = orderQueue.shift();
  saveState();
  const obj = allWords.find(w=>w.rawLine===currentRaw) || { rawLine: currentRaw, rus:[''], arab: '' };
  arabicDiv.textContent = obj.arab || '[нет арабской формы]';
  showMessage('Нажмите "Знаю" или "Не знаю".');
  practiceArea.classList.add('hidden');
  updateStats();
}

/* ========== Обработчики кнопок заучивания ========= */
btnKnow.addEventListener('click', () => {
  if(!currentRaw) return;
  // пометить как выученное в этом раунде; пока не удаляем окончательно — окончательное удаление произойдёт в практике
  if(!roundMastered.includes(currentRaw)) roundMastered.push(currentRaw);
  // также добавляем в practiceAccum (накопление практики)
  if(!practiceAccum.includes(currentRaw)) practiceAccum.push(currentRaw);
  // не возвращаем это слово в очередь — оно не будет показываться в learn пока не сбросят прогресс или не вернётся из practice
  currentRaw = null;
  updateStats();
  saveState();
  // если достигнут порог — начинаем практику
  if(roundMastered.length >= BATCH_SIZE){
    startPractice();
  } else {
    // отображаем следующее слово
    showNextLearn();
  }
});

btnDont.addEventListener('click', () => {
  if(!currentRaw) return;
  // показать модал с переводами и арабской формой на 15 сек
  const obj = allWords.find(w=>w.rawLine===currentRaw) || { rawLine: currentRaw, rus:[''], arab: '' };
  showModalDontKnow(obj);
  // вернуть слово в конец очереди (чтобы повторить позднее)
  orderQueue.push(currentRaw);
  currentRaw = null;
  saveState();
});

/* ========== Модалка "Не знаю" ========= */
function showModalDontKnow(obj){
  closeModal();
  const overlay = document.createElement('div'); overlay.className = 'overlay';
  const modal = document.createElement('div'); modal.className = 'modal';
  modal.innerHTML = `
    <div style="display:flex;justify-content:space-between;align-items:center">
      <strong>Перевод (15 с)</strong>
      <button id="modal-close" style="padding:6px 8px;border-radius:6px">Закрыть</button>
    </div>
    <div class="arab" style="margin-top:8px">${escapeHtml(obj.arab || '')}</div>
    <div class="rus">${escapeHtml((obj.rus||[]).join(', '))}</div>
  `;
  overlay.appendChild(modal);
  modalRoot.appendChild(overlay);

  function closeHandler(){ cleanup(); }
  function cleanup(){
    if(modalTimer) { clearTimeout(modalTimer); modalTimer = null; }
    const b = document.getElementById('modal-close');
    if(b) b.removeEventListener('click', closeHandler);
    if(overlay.parentNode) overlay.parentNode.removeChild(overlay);
  }

  const closeBtn = document.getElementById('modal-close');
  if(closeBtn) closeBtn.addEventListener('click', closeHandler);
  modalTimer = setTimeout(()=>{ cleanup(); showNextLearn(); }, AUTO_CLOSE_MODAL_MS);
}

/* ========== Закрыть модалку ========= */
function closeModal(){
  modalRoot.innerHTML = '';
  if(modalTimer){ clearTimeout(modalTimer); modalTimer = null; }
}

/* ========== Практика ========= */
function startPractice(){
  phase = 'practice';
  // practiceOrder — копия practiceAccum, shuffle
  practiceOrder = practiceAccum.slice();
  shuffle(practiceOrder);
  // очистим roundMastered — они теперь часть practiceAccum
  roundMastered = [];
  saveState();
  updateStats();
  showNextPractice();
}

function showNextPractice(){
  if(!practiceOrder || practiceOrder.length === 0){
    // practice finished -> back to learning if queue not empty
    practiceAccum = practiceAccum.filter(r => !masteredFinal.includes(r)); // keep only not-final
    // если в practiceAccum нет слов и очередь пуста — всё пройдено
    if(orderQueue.length === 0 && practiceOrder.length === 0 && practiceAccum.length === 0){
      showMessage('Поздравляю — вы прошли все слова!');
      arabicDiv.textContent = '🎉 Всё выучено';
      phase = 'done';
      saveState();
      updateStats();
      return;
    }
    // перейти обратно в learn
    phase = 'learn';
    saveState();
    updateStats();
    showNextLearn();
    return;
  }
  // показываем слово для практики
  currentRaw = practiceOrder.shift();
  const obj = allWords.find(w=>w.rawLine===currentRaw) || { rawLine: currentRaw, rus:[''], arab: '' };
  arabicDiv.textContent = obj.arab || '[нет арабской формы]';
  practiceArea.classList.remove('hidden');
  practiceInput.value = '';
  practiceInput.focus();
  updateStats();
}

/* проверка практики (ввод пользователем на русском) */
practiceSubmit.addEventListener('click', () => {
  if(!currentRaw) return;
  const val = (practiceInput.value||'').trim().toLowerCase();
  if(!val) return;
  const obj = allWords.find(w=>w.rawLine===currentRaw) || { rus: [''] };
  // считаем ответ верным, если совпадает с любым вариантом (упрощённо, нормализуем через toLowerCase())
  const ok = (obj.rus||[]).some(r => r.trim().toLowerCase() === val || r.trim().toLowerCase() === val.replace(/ё/g,'е'));
  if(ok){
    // окончательно выучено
    if(!masteredFinal.includes(currentRaw)) masteredFinal.push(currentRaw);
    // убрать из practiceAccum если есть
    practiceAccum = practiceAccum.filter(r=>r!==currentRaw);
    showMessage('Верно — слово отмечено как выученное.');
    saveState();
    updateStats();
    // следующий
    currentRaw = null;
    practiceInput.value = '';
    showNextPractice();
  } else {
    // ошибка → вернуть в общую очередь для заучивания
    orderQueue.push(currentRaw);
    // также убрать из practiceAccum (ибо вернули в learn)
    practiceAccum = practiceAccum.filter(r=>r!==currentRaw);
    showMessage('Неправильно — слово возвращено в очередь для заучивания.');
    saveState();
    updateStats();
    currentRaw = null;
    practiceInput.value = '';
    showNextPractice();
  }
});

/* пропустить — вернуть в очередь и продолжить */
practiceSkip.addEventListener('click', () => {
  if(!currentRaw) return;
  orderQueue.push(currentRaw);
  practiceAccum = practiceAccum.filter(r=>r!==currentRaw);
  saveState();
  showMessage('Слово пропущено и возвращено в очередь для заучивания.');
  currentRaw = null;
  showNextPractice();
});

/* ========== Добавить новые слова (только новые) ========= */
btnAdd.addEventListener('click', async () => {
  try{
    const txt = await robustFetchWords();
    const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    const existing = new Set(allWords.map(w=>w.rawLine));
    let added = 0;
    for(const l of lines){
      const n = normalizeLine(l);
      if(!existing.has(n)){
        const obj = parseLine(n);
        allWords.push(obj);
        orderQueue.push(obj.rawLine);
        existing.add(n);
        added++;
      }
    }
    if(added) shuffle(orderQueue); // перемешать новые
    saveState();
    updateStats();
    alert('Добавлено новых слов: ' + added);
  }catch(e){
    alert('Не удалось добавить слова: ' + e.message);
  }
});

/* ========== Сброс прогресса ========= */
btnReset.addEventListener('click', () => {
  if(!confirm('Сбросить прогресс? Это удалит локальные данные и вернёт словарь в начало.')) return;
  clearState();
  // переинициализируем словарь заново (загрузит words.txt и покажет дуа)
  // проще — перезагрузим страницу, чтобы гарантированно сбросить все состояния
  location.reload();
});

/* ========== Esc для закрытия модалки (если открыт) ========= */
document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape'){ closeModal(); } });

/* ========== Проверка завершения/сохранение перед уходом ========= */
window.addEventListener('beforeunload', saveState);
window.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='hidden') saveState(); });

/* ========== Вспомогательные ========= */
function escapeHtml(s){ return String(s || '').replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* ========== Обработчик "Я сделал дуа" — показать основной экран и продолжить ========= */
btnDoneDua.addEventListener('click', async () => {
  // скрыть дуа, показать тренировку
  screenDua.classList.add('hidden');
  screenMain.classList.remove('hidden');
  // если словарь ещё не инициализирован — инициализировать
  if(!allWords.length){
    await initDictionary();
  }
  // если currentRaw восстановлен — показать его (в зависимости от фазы)
  if(phase === 'practice' && practiceOrder.length){
    // показать практику
    practiceArea.classList.remove('hidden');
    showNextPractice();
  } else {
    practiceArea.classList.add('hidden');
    // если был currentRaw (восстановлен), отобразить; иначе взять следующий
    if(currentRaw){
      const o = allWords.find(w=>w.rawLine===currentRaw);
      arabicDiv.textContent = o ? (o.arab || o.rawLine) : currentRaw;
    } else {
      showNextLearn();
    }
  }
});

/* ========== Инициализация при загрузке страницы: загрузить словарь, но показывать дуа экран ========== */
(async function bootstrap(){
  // заранее загружаем словарь и пытаемся восстановить состояние, но не начинаем сессии — покажем дуа
  try{
    await initDictionary();
    // показать дуа (по умолчанию), main скрыт
    screenDua.classList.remove('hidden');
    screenMain.classList.add('hidden');
  }catch(e){
    console.error(e);
    alert('Ошибка инициализации: ' + e.message);
  }
})();
</script>
</body>
</html>
